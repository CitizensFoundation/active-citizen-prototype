# List mutators: generated by the ListMutator function

# The mutation strategies for ListMutator
# * :single_point : Mutates a single element
# * :n_point[n=3] : Mutates a single element, n times.     Example: :n_point, :n_point[2]
# * :probability[ p=0.05 ] : Mutates each element with probability p
# * :expected_n[n=3]     : Mutates each element with probability n/genes.size, i.e. such that the expected # of mutations is n
MutationStrategies = {  # TODO: change to default parameters in 1.9
  :probability => Proc.new{|genes,pointmut,p| 
    p ||= 0.05
    genes.map!{|e| rand < p ? pointmut.call(e) : e }
  },
  :expected_n => Proc.new{|genes,pointmut,n|
    n ||= 3
    p   = n.to_f / genes.size
    genes.map!{|e| rand < p ? pointmut.call(e) : e }
  },
  :single_point => Proc.new{|genes,pointmut|
    i = genes.rand_index
    genes[i] = pointmut.call(genes[i])
  },
  :n_point => Proc.new{|genes,pointmut,n|
    n ||= 3
    n.times{ i = genes.rand_index; genes[i] = pointmut.call(genes[i]) }
  }
}

# The point mutators for ListMutator
# * :flip                  :  flips bit (x->1-x), use in BitStringGenotype
# * :replace[ c1,c2,...,cn ]  :  replaces the element with one of the arguments. use in StringGenotype.  Example: :replace[ *'a'..'z' ]
# * :uniform[ max_size=0.25 ]:  adds a random number in the range [-max_size,+max_size], uniformly distributed.
# * :gaussian[ sigma=0.2 ]   :  adds a random number, gaussian distributed with standard deviation sigma
PointMutators = {
  :replace => proc{|x,*pos| pos.at_rand },
  :flip    => proc{|x| 1-x },
  :uniform => Proc.new{|x,max_size| max_size ||= 0.25;  x - max_size + max_size * 2 * rand },
  :gaussian=> Proc.new{|x,sigma|
     sigma ||= 0.2;
     delta = Math.sqrt(-2 * Math.log(rand)) * Math.cos(2 * Math::PI * rand)  # Box-Muller transformation
     x + delta * sigma
   }
}

# Generates a module which can be used as a mutator for array-based genotypes like FloatListGenotype, BitStringGenotype and StringGenotype
# * strategy      should be one of the MutationStrategies, or a proc
# * point_mutator should be one of the PointMutators, or a proc
# * nil is equivalent to proc{} for the point mutator
def ListMutator(strategy=:expected_n ,point_mutator=:uniform)
  strat, *strat_args = *strategy
  pm   , *pm_args    = *point_mutator

  pm ||= proc{}

  strat = MutationStrategies[strat.intern] unless strat.is_a? Proc
  pm    = PointMutators[pm.intern]         unless pm.is_a? Proc
  
  raise ArgumentError,"Invalid mutation strategy" if strat.nil?
  raise ArgumentError,"Invalid point mutator"     if point_mutator.nil?

  if pm_args.empty?
    point_mutator_with_args = pm    
  else
    point_mutator_with_args = proc{|*args| pm.call(*(args+pm_args) ) }
  end

  Module.new{
    define_method(:mutate!) {
#       puts "ListMutator"
#      puts "IN LIST MUTATOR #{self.object_id}"
#      puts "list_mutator #{self.object_id} #{@genes}"
      strat.call(@genes,point_mutator_with_args,*strat_args)
      self
    }
    self.name= "ListMutator(#{strategy.inspect},#{point_mutator.inspect})"
  }
end

def ComboMutator
  Module.new{
    define_method(:mutate!) {
#       puts "ComboMutator"
#      puts "GENOTYPES LENGTH: #{@genotypes.length}"
#      @genotypes.each{|g| puts "BEFORE: #{g}"; g.mutate!; puts "AFTERR: #{g}"}
      for n in 0..@genotypes.length-1
#        puts "ComboMutator BEFORE #{self.object_id} #{@genotypes[n].genes}"
        @genotypes[n] = @genotypes[n].mutate!
#        puts "ComboMutator AFTERE #{self.object_id} #{@genotypes[n].genes}"
      end
      self
    }
    self.name= "ComboMutator"
  }
end